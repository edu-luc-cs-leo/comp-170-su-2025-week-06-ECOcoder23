                                                    Review
    
    My function named "intersection" with creates a string out of the characters shared by two other strings "foo" and "bar" 
more or less uses similar mechanisms to the intersection function defined in the solution code. Both functions traverse the strings "foo" and "bar" one character at a time, looking for a shared character, which is subsequently added to an empty string (given the variable name "result" in my case and "intersection_string" in the case of the solution code). The previously empty string, now concatenated with the intersecting characters, is then returned as the function output. 

    My function named "is_alphabetical" functions in an identical fashion to its counter-part in the solution code. Both functions
analyze each character in a string, starting from the 0th character. The character is analyzed by checking whether its ASCII value is within the range of uppercase or lowercase letters. If its ASCII value matches either of these ranges, then the code moves on to string character number n + 1. If at any point a character is found outside of these ASCII value ranges, the function returns the boolean result "False". If all characters are within either of these ranges, the function returns the result "True". The only noticeable difference between my code and the solution code is that the solution code uses ">=" and "<=" to define the ASCII value ranges while my code creates two integer ranges (one for lowercase letters and one for uppercase letters). 

    My funtion "letters_only" which turns a string with only alphabetical characters after being given a string as an input works 
similarly to my function "is_alphabetical". The function, starting from the 0th character in the input string, checks if the character is within the ASCII value range for upper-case or lower-case letters. If its ASCII value is indeed in either range, the character is added to an empty string "result". If its ASCII value is not found in either range, nothing is added to "result". The code moves on to character numner n + 1 until it has gone over every character in the input string. This is identical to the solution code methodology, save for the fact that it uses "<=" and ">=" to define the ASCII values of alphabetical characters. 

    My function "generate_palindrome" seems to have a fair bit more complexity than the solution code and also did not always
generate an appropriate output. The solution code creates a variable called "pali" and then sets this variable equal to the input string. Next, the characters from the input string, starting from index position "[-1]" are concatenated to the string "pali", creating a version of the input string that reads the same left-to-right and right-to-left. My function begins by turning the input string into list of its constituant characters named "string_list". Another list is also created named "mirror" with the same items as the "string_list" but in reverse order. A final list ("new_string_list) is made, which is the result of the concatenation of the "string_list" and "mirror". Finally, the items of "new_string_list" are joined using the join() function, creating a singular string named "palin_str", which is returned as the function output. 

My function "is_palindrome" also differed significantly from the solution code methodology. In the solution code, the input string has all of its characters turned into uppercase letters using the upper() string function. Then, two variables are defined, "rightbound" (with a value of zero) and "leftbound" (with a value equivalent to the string length minus one). One character at a time, the code analyzes both the "rightbound" and "leftbound" ends of the input string and checking whether they match. Any characters that are not alphanumerical are skipped. If all characters match, "is_pali" equals "True". Otherwise, the output is "False". My function on the other hand, begins by turning all characters of the input string into lowercase alphabetical letters. Using string splitting techniques, the transformed input string is divided into two strings of equivalent length, one containing characters of the first half of the string, and the other containing all characters of the second half. Finally, the string containing the second half of the input string has its characters read in reverse order (last character to first) and is compared to the first half of the input string. If both are equivalent, the function output is "True". If both halves of the string are either not equivalent or the input string has no characters, the function output is "False".